import { NightDay } from './Onah';
import Entry from './Entry';
import { Kavuah, KavuahTypes } from './Kavuah';
import ProblemOnah from './ProblemOnah';
import ProblemFlag from './ProblemFlag';
import JDate from '../JCal/JDate';
import Settings from '../Settings';

/**
 * Returns true if the given date and NightDay are after the setting entry date
 * of the given Kavuah.
 * This is used to determine if a Problem Onah is after the setting entry of
 * a cancelling Kavuah in order to prevent its flagging.
 * @param {JDate} date
 * @param {NightDay} nightDay
 * @param {Kavuah} cancelKavuah
 */
function isAfterKavuahStart(
  date: JDate,
  nightDay: NightDay,
  cancelKavuah: Kavuah
): boolean {
  if (cancelKavuah) {
    const { settingEntry } = cancelKavuah;
    return (
      settingEntry &&
      (date.Abs > settingEntry.date.Abs ||
        (date.Abs === settingEntry.date.Abs &&
          nightDay > settingEntry.nightDay))
    );
  }
  return false;
}

/**
 * This class is used to Generate Problem Onahs from
 * a list of Entries, a list of Kavuahs and a Settings object.
 * Use: new FlaggedDatesGenerator(entries, kavuahs, settings).getProblemOnahs()
 */
export default class FlaggedDatesGenerator {
  entries: Array<Entry>;

  kavuahs: Array<Kavuah>;

  settings: Settings;

  cancelKavuah?: Kavuah;

  probOnahs: Array<ProblemOnah>;

  stopWarningDate: JDate;

  constructor(
    entries: Array<Entry>,
    kavuahs: Array<Kavuah>,
    settings: Settings
  ) {
    this.entries = entries;
    this.settings = settings;
    this.kavuahs =
      (kavuahs && kavuahs.filter(k => k.active && !k.ignore)) || [];
    this.cancelKavuah = kavuahs.find(k => k.active && k.cancelsOnahBeinunis);
    this.probOnahs = [];
    this.stopWarningDate = JDate.toJDate().addMonths(
      this.settings.numberMonthsAheadToWarn
    );
  }

  /**
   * Gets the list of Onahs that need to be observed.
   * Problem Onahs are searched for from the date of each entry
   * until the number of months specified in the
   * Property Setting "numberMonthsAheadToWarn"
   * @returns {[ProblemOnah]}
   */
  getProblemOnahs(): Array<ProblemOnah> {
    // Clean the list
    this.probOnahs = [];

    // Find Flagged Dates that need to be calculated from the list of Entries.
    this.entries.forEach(entry => {
      this.findOnahBeinunisProblemOnahs(entry, this.cancelKavuah);
      // Get problems generated by active Kavuahs
      this.findEntryDependentKavuahProblemOnahs(entry);
    });

    // Get the onahs that need to be kept for Kavuahs of Yom Hachodesh, Sirug,
    // and other Kavuahs that are not dependent on the actual entry list
    this.findIndependentKavuahProblemOnahs();

    // Sort the problem list and return it
    return ProblemOnah.sortProbList(this.probOnahs);
  }

  findOnahBeinunisProblemOnahs(entry: Entry, cancelKavuah?: Kavuah) {
    // Yom Hachodesh ***************************************************************
    const nextMonth = entry.date.addMonths(1);
    // If Yom Hachodesh was 30 and this month only has 29 days,
    // the 29th and the 1st should both be flagged.
    // In the above scenario, jdate.addMonths will automatically change the Day to 29.
    const hasFullMonthIssue = entry.date.Day === 30 && nextMonth.Day === 29;

    if (
      !cancelKavuah ||
      !isAfterKavuahStart(nextMonth, entry.nightDay, cancelKavuah)
    ) {
      const yomHachodesh = new ProblemFlag(
        nextMonth,
        entry.nightDay,
        `Yom Hachodesh${hasFullMonthIssue ? ' (changed from 30 to 29)' : ''}`
      );
      this.addProblem(yomHachodesh);
      this.add24HourOnah(yomHachodesh);
      // We won't flag the Ohr Zarua if it's included in Onah Beinonis
      // of 24 hours as Onah Beinonis is stricter.
      if (
        !this.settings.onahBeinunis24Hours ||
        entry.nightDay === NightDay.Night
      ) {
        this.addOhrZarua(yomHachodesh);
      }
    }
    // If Yom Hachodesh was 30 and this month only has 29 days, we add the 1st of the next month.
    if (hasFullMonthIssue) {
      const nextDay = nextMonth.addDays(1);
      if (
        !cancelKavuah ||
        !isAfterKavuahStart(nextDay, entry.nightDay, cancelKavuah)
      ) {
        const yomHachodesh2 = new ProblemFlag(
          nextDay,
          entry.nightDay,
          'Yom Hachodesh (changed from 30 to 1)'
        );
        this.addProblem(yomHachodesh2);
        this.add24HourOnah(yomHachodesh2);
        // We won't flag the Ohr Zarua if it's included in Onah Beinonis
        // of 24 hours as Onah Beinonis is stricter.
        if (
          !this.settings.onahBeinunis24Hours ||
          entry.nightDay === NightDay.Night
        ) {
          this.addOhrZarua(yomHachodesh2);
        }
      }
    }
    // Day Thirty ***************************************************************
    // we only need to add 29 days as the entry date is day one
    const dayThirty = entry.date.addDays(29);
    if (
      !cancelKavuah ||
      !isAfterKavuahStart(dayThirty, entry.nightDay, cancelKavuah)
    ) {
      const thirty = new ProblemFlag(
        dayThirty,
        entry.nightDay,
        'Thirtieth Day'
      );
      this.addProblem(thirty, entry);
      this.add24HourOnah(thirty, entry);
      // We won't flag the Ohr Zarua if it's included in Onah Beinonis
      // of 24 hours as Onah Beinonis is stricter.
      if (
        !this.settings.onahBeinunis24Hours ||
        entry.nightDay === NightDay.Night
      ) {
        this.addOhrZarua(thirty, entry);
      }
    }
    // Day Thirty One ***************************************************************
    if (this.settings.keepThirtyOne) {
      const dayThirtyOne = dayThirty.addDays(1);
      if (
        !cancelKavuah ||
        !isAfterKavuahStart(dayThirtyOne, entry.nightDay, cancelKavuah)
      ) {
        const thirtyOne = new ProblemFlag(
          dayThirtyOne,
          entry.nightDay,
          'Thirty First Day'
        );
        this.addProblem(thirtyOne, entry);
        this.add24HourOnah(thirtyOne, entry);
        // We won't flag the Ohr Zarua if it's included in Onah Beinonis
        // of 24 hours as Onah Beinonis is stricter.
        if (
          !this.settings.onahBeinunis24Hours ||
          entry.nightDay === NightDay.Night
        ) {
          this.addOhrZarua(thirtyOne, entry);
        }
      }
    }
    // Haflagah **********************************************************************
    const haflagaDate = entry.date.addDays(entry.haflaga - 1);
    if (
      entry.haflaga > 0 &&
      (!cancelKavuah ||
        !isAfterKavuahStart(haflagaDate, entry.nightDay, cancelKavuah))
    ) {
      const haflaga = new ProblemFlag(
        haflagaDate,
        entry.nightDay,
        `Yom Haflagah (of ${entry.haflaga.toString()} days)`
      );
      // Note the Haflaga is always just the Onah it occurred on - not 24 hours  -
      // even according to those that require it for 30, 31 and Yom Hachodesh.
      this.addProblem(haflaga, entry);
      this.addOhrZarua(haflaga, entry);
    }
    // Haflagah of Onahs *************************************************************
    if (this.settings.haflagaOfOnahs) {
      const prevEntry = this.entries[this.entries.indexOf(entry) - 1];
      // If they have the same nightDay then it will be a regular haflaga
      if (prevEntry && prevEntry.nightDay !== entry.nightDay) {
        const diffOnahs = prevEntry.getOnahDifferential(entry);
        const nextOnah = entry.onah.addOnahs(diffOnahs);
        if (
          !cancelKavuah ||
          !isAfterKavuahStart(nextOnah.jdate, nextOnah.nightDay, cancelKavuah)
        ) {
          const haflagaOnahs = new ProblemFlag(
            nextOnah.jdate,
            nextOnah.nightDay,
            `Haflagah of Onahs (of ${diffOnahs.toString()} onahs)`
          );
          this.addProblem(haflagaOnahs);
          this.addOhrZarua(haflagaOnahs);
        }
      }
    }
    // The Ta"z
    if (this.settings.keepLongerHaflagah) {
      const probs: Array<ProblemFlag> = [];
      // Go through all earlier entries in the list that have a longer haflaga than this one
      // and that are not kept anyway due to onah beinonis,
      this.entries
        .filter(
          en =>
            en.date.Abs < entry.date.Abs &&
            en.haflaga > entry.haflaga &&
            en.haflaga !== 30 &&
            (en.haflaga !== 31 || !this.settings.keepThirtyOne)
        )
        .forEach(e => {
          // See if their haflaga was never surpassed by an Entry after them
          if (
            !this.entries.some(
              oe => oe.date.Abs > e.date.Abs && oe.haflaga > e.haflaga
            )
          ) {
            const dateHaflaga = entry.date.addDays(e.haflaga - 1);
            if (
              !cancelKavuah ||
              !isAfterKavuahStart(dateHaflaga, entry.nightDay, cancelKavuah)
            ) {
              const nonOverrided = new ProblemFlag(
                dateHaflaga,
                entry.nightDay,
                `Yom Haflaga (${e.haflaga.toString()} days) which was never overrided`
              );
              // As there can be more than single longer haflaga'd Entry with the same haflaga,
              // we want to prevent doubles.
              if (!probs.some(p => p.isSameProb(nonOverrided))) {
                probs.push(nonOverrided);
              }
            }
          }
        });

      probs.forEach(prob => {
        this.addProblem(prob);
        this.addOhrZarua(prob);
      });
    }
  }

  findEntryDependentKavuahProblemOnahs(entry: Entry) {
    // Kavuah Haflagah - with or without Maayan Pasuach
    this.kavuahs
      .filter(k =>
        [KavuahTypes.Haflagah, KavuahTypes.HaflagaMaayanPasuach].includes(
          k.kavuahType
        )
      )
      .forEach(kavuah => {
        const haflagaDate = entry.date.addDays(kavuah.specialNumber - 1);
        const kavuahHaflaga = new ProblemFlag(
          haflagaDate,
          kavuah.settingEntry.nightDay,
          `Kavuah of ${kavuah.toString()}`
        );
        this.addProblem(kavuahHaflaga);
        this.addOhrZarua(kavuahHaflaga);
      });

    // Kavuah of Dilug Haflaga.
    // They are cheshboned from actual entries - not theoretical ones
    this.kavuahs
      .filter(k => k.kavuahType === KavuahTypes.DilugHaflaga && k.active)
      .forEach(kavuah => {
        if (entry.haflaga > 0 && entry.haflaga + kavuah.specialNumber !== 0) {
          const haflagaDate = entry.date.addDays(
            entry.haflaga + kavuah.specialNumber - 1
          );
          const kavuahDilugHaflaga = new ProblemFlag(
            haflagaDate,
            kavuah.settingEntry.nightDay,
            `Kavuah of ${kavuah.toString()}`
          );
          this.addProblem(kavuahDilugHaflaga);
          this.addOhrZarua(kavuahDilugHaflaga);
        }
      });
    // Flagged Dates generated by Kavuahs of Haflagah by Onahs - the Shulchan Aruch Harav
    this.kavuahs
      .filter(k => k.kavuahType === KavuahTypes.HaflagaOnahs)
      .forEach(kavuah => {
        const haflagaOnah = entry.onah.addOnahs(kavuah.specialNumber);
        const kavuahHafOnahs = new ProblemFlag(
          haflagaOnah.jdate,
          haflagaOnah.nightDay,
          `Kavuah of ${kavuah.toString()}`
        );
        this.addProblem(kavuahHafOnahs);
        this.addOhrZarua(kavuahHafOnahs);
      });
  }

  findIndependentKavuahProblemOnahs() {
    // "Independent" Kavuahs which are cheshboned from the theoretical Entries
    this.kavuahs
      .filter(k => k.isIndependent)
      .forEach(kavuah => {
        const iters = Kavuah.getIndependentIterations(
          kavuah,
          this.stopWarningDate,
          this.settings.dilugChodeshPastEnds
        );
        iters.forEach(onah => {
          const problemFlag = new ProblemFlag(
            onah.jdate,
            onah.nightDay,
            `Kavuah for ${kavuah.toString()}`
          );
          this.addProblem(problemFlag);
          this.addOhrZarua(problemFlag);
        });
      });
  }

  add24HourOnah(prob: ProblemFlag, entry?: Entry) {
    if (this.settings.onahBeinunis24Hours) {
      this.addProblem(
        new ProblemFlag(
          prob.jdate,
          prob.nightDay === NightDay.Day ? NightDay.Night : NightDay.Day,
          `${prob.description} (24 hour)`
        ),
        entry
      );
    }
  }

  addOhrZarua(prob: ProblemFlag, entry?: Entry) {
    // If the user wants to keep the Ohr Zarua  - the previous onah
    if (this.settings.showOhrZeruah) {
      const ohrZarua = prob.onah.previous;
      this.addProblem(
        new ProblemFlag(
          ohrZarua.jdate,
          ohrZarua.nightDay,
          `Ohr Zarua of the ${prob.description}`
        ),
        entry
      );
    }
  }

  /**
   * Add the given ProblemFlag to the flagsList of the ProblemOnah for the given Onah.
   * If there isn't yet a ProblemOnah for this Onah in this.probOnahs, it will be added.
   * @param {ProblemFlag} probFlag
   * @param {Entry} [settingEntry] optional entry to pass on to the _canAddFlaggedDate function.
   */
  addProblem(probFlag: ProblemFlag, settingEntry?: Entry) {
    if (this.canAddFlaggedDate(probFlag, settingEntry)) {
      let probOnah = this.probOnahs.find(po => po.isSameOnah(probFlag.onah));
      if (!probOnah) {
        probOnah = new ProblemOnah(probFlag.jdate, probFlag.nightDay);
        this.probOnahs.push(probOnah);
      }
      probOnah.flagsList.push(probFlag);
    }
  }

  /**
   * Returns false if the noProbsAfterEntry setting is on and there was an Entry
   * in the 7 days before the given flags onah.
   * Will also return false if the settingEntry is supplied, and keepLongerHaflagah is off,
   * and there was another entry between the settingEntry and the problem onah.
   * This is to prevent flagging haflaga type problems when there were other entries before the problem onah.
   * @param {ProblemFlag} probFlag
   * @param {Entry} [settingEntry] if supplied and the keepLongerHaflagah is off and
   * there was another Entry between the settingEntry and the problem onah,
   * will cause this function to return false.
   */
  canAddFlaggedDate(probFlag: ProblemFlag, settingEntry?: Entry) {
    const { jdate } = probFlag;
    const { nightDay } = probFlag;
    if (
      !this.settings.keepLongerHaflagah &&
      settingEntry &&
      this.entries.some(
        e =>
          // If there is an Entry in the list that is after the setting entry
          (e.date.Abs > settingEntry.date.Abs ||
            (e.date.Abs === settingEntry.date.Abs &&
              e.nightDay > settingEntry.nightDay)) &&
          // and that entry is before the prospective problem onah
          (e.date.Abs < jdate.Abs ||
            (e.date.Abs === jdate.Abs && e.nightDay < nightDay))
      )
    ) {
      // The problem will not be flagged
      return false;
    }
    if (!this.settings.noProbsAfterEntry) {
      return true;
    }
    return !this.entries.some(
      en =>
        en.date.Abs >= jdate.Abs - 7 &&
        (en.date.Abs < jdate.Abs ||
          (en.date.Abs === jdate.Abs && en.nightDay < nightDay))
    );
  }
}
